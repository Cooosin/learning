# Mysql

#### 基础架构

##### 一条Select 语句的具体执行过程

![img](https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png?wh=1920*1440)

1. 连接器

- 与客户端进行 TCP 三次握手建立连接；

- 校验客户端的用户名和密码，读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限

- 长连接：Mysql在执行过程中临时使用的内存存在连接对象里面的， 因此只有断开连接的时候才会被释放，此时就有可能出现内存占用过大的情况

  - 问题本质：
    - 每个连接都有自己的内存缓存区大小限制，这里本质是由于链接数过多，而每个连接又占用了大量内存才会导致整体内存过大OOM
    - 因此在应用会使用连接池去控制连接数大小

  - 解决方法：
    1. 定期断开长连接
    2. 每次在执行比较大的操作过后，通过执行mysql_reset_connection来重新初始化连接资源

- 如果一个长连接没有任何动作，会被视为空闲状态，如果长时间空闲，连接器就会自动将他断开，这个时间由wait_timeout控制，默认是**8小时** 

2. 分析器
   - 进行语法分析，判断sql语句是否能被正常识别运行，是否满足MYSQL语法
3. 查询缓存
   - 就是把查询的结果缓存起来，大多数情况不使用，因为命中率太低
   - mysql8.0已经将这里的整块功能删掉了

2. 优化器
   - 生成执行计划，如在表有多条索引的时候，决定使用哪条索引，一个语句有多表关联的时候，决定各个表的关联顺序
3. 执行器
   - 执行语句，判断是否有权限，有权限则根据表的引擎定义，去使用这个引擎所提供的接口



## 一条Update语句的具体执行过程

1. 首先查询语句的那一套流程，在更新语句的时候也会同样走一遍
2. 更新流程主要涉及到两个重要的日志模块，redo log(重做日志) 和 binlog(归档日志)
3. 在进行更新语句的时候，mysql会先将更新操作记录在redolog中，并更新内存，这个时候，更新操作就算完成了，InnoDB引擎会在适当的时候，将这个操作真正的记录更新到磁盘当中
4. InnoDB的redo log是固定大小的，write pos是当前记录的位置，一边写一遍后移，check point当前擦除更新的位置，擦除之前把记录更新到数据文件，当write pos追上check point时，就会停止更新操作，先进行擦除操作，将Checkpoint推进一下
5. 有了redo log还可以保证数据库发生异常重启的时候，之前提交的记录都不会消失，这个能力称为 crash-safe
6. binlog :为Server层独有的日志，没有 crash-safe
   - redolog 是innoDB引擎特有的
   - redolog是物理日志，记录的是在这个数据页上进行了什么修改，binlog是逻辑日志，直接记录原始逻辑操作
   - redoglog是循环写的，会覆盖之前的数据，binlog是追加写的，并不会覆盖之前的数据

- 因此binlog会记录一段时间的所有操作，而redolog会覆盖写，因此只会一小段的记录。并不完整

![img](https://static001.geekbang.org/resource/image/16/a7/16a7950217b3f0f4ed02db5db59562a7.png?wh=1142*856)

### 两阶段提交

- 核心点：
  1. 引擎先将数据更新至内存中，然后将这个操作记录写到redolog中，记为prepare
  2. 然后执行器再生成这个操作的binlog，将binlog落盘
  3. 最后将事务commit，将redolog的状态更改为commit
- 两阶段提交是为了保证两个log的数据一致，以防止主备同步或其他场景导致数据不一致
- 思考：
  - 如果在commit阶段宕机了，那么在mysql重启的时候，会先检查redolog的状态
    - 如果redolog的状态是prepare，那么去检查binlog是否写入磁盘了
      - 如果binlog写入磁盘了，那么就将redolog的状态改为commit
      - 如果没有写入磁盘，则将该redolog丢弃，回滚这个事务

![img](https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/MySQL%e5%ae%9e%e6%88%9845%e8%ae%b2/assets/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png)

------

## MYSQL事务

### 特性

1. 原子性：即事务里的所有操作要么全部完成，全部不完成，不允许有中间状态
2. 隔离性：每个事务里面的操作的相互隔离的，可以防止多个事务并行操作导致的数据不一致
3. 一致性：事务操作前操作后，数据是完整一致的，比如A给B转账200元，最后一定是A少了200元，B多了200元
4. 持久性：事务处理结束后，对数据的修改就是永久的，即使宕机也不会丢失

在InnoDB中：

- 通过redolog保证持久性
- 通过undolog保证原子性
- 通过mvcc或者锁保证隔离性
- 通过以上三个保证一致性

### 并行事务引发的问题

1. 脏读：一个事务读到另外一个未提交事务修改过的数据
2. 不可重复读：指在一个事务中读同一条数据，前后两次读取的数据不一致，即数据被修改了
3. 幻读：**在一个事务内多次查询某个符合查询条件的「记录数量」，出现前后两次查询到的记录数量不一样**



### MVCC

- 对于可重复读和读提交是通过`Read View`来实现的，ReadVIew本质上其实就是快照，可重复读是在开启事务的时候去生成一个`Read View`，而读提交是每个语句执行前重新生成一个`Read View`

- #### ReadView在MVCC的工作原理

  - ReadView中的四个字段

    1. m_Iids：就是数据库中开启了但事务但未提交的事务id列表
    2. creator_trx_id:就是创建该视图的事务ID
    3. min_trx_id:当前数据库中活跃且未提交事务中最小事务的事务ID
    4. mat_trx_id：记录着当前事务最大id+1

    ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/readview%E7%BB%93%E6%9E%84.drawio.png)

  - 索引记录的两个隐藏列

    1. trx_id：最新修改该列的事务ID
    2. roll_pointer:每次对记录进行修改的时候，都会把旧数据写进undolog，然后这里隐藏列是个指针，就是指向上一个旧版本的记录

    ![图片](https://cdn.xiaolincoding.com//mysql/other/f595d13450878acd04affa82731f76c5.png)

  

- 一个事务去访问记录的时候，会有以下几种情况
  1. 记录的trx_id小于当前min_trx_id，证明该修改记录对当前事务可见
  2. 记录的trx_id大于max_trx_id，则证明该修改记录对当前事务不可见，则去roll_pointer去拿上一个提交的旧数据
  3. 记录的trx_id如果在min_trx_id和max_trx_id之间，则去判断在不在trx_ids在列表中，如果不在，则证明该事务已经提交（是可见的），否则则证明该事务未提交，不可见

### 隔离级别

- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。**Innodb默认的隔离级别** 
- 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

## 索引

### 定义：

- 帮助存储引擎快速获取数据的一种数据结构(索引是数据的目录)

### 索引的分类

- 按「数据结构」分类：**B+tree索引、Hash索引、Full-text索引**。
- 按「物理存储」分类：**聚簇索引、非聚簇索引**。
- 按「字段特性」分类：**主键索引、唯一索引、普通索引、前缀索引**。
- 按「字段个数」分类：**单列索引、联合索引**。

### 建表的默认索引(InnoDB存储引擎)

- 如果有主键，默认会使用主键作为聚簇索引的索引键（key）；
- 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；
- 在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；

(其他索引都属于非聚簇索引)

### B+树的数据结构

- B+树是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，每个节点的数据是按顺序存放的，在叶子节点存放着所有的索引值信息，并且每一个叶子节点都指向下一个叶子节点，形成一个链表、

#### 聚簇索引

![主键索引 B+Tree](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/btree.drawio.png)

优点：B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，所以**B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次。**

#### 非聚簇索引

![二级索引 B+Tree](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95btree.drawio.png)

- 在非聚簇索引中的B+Tree的叶子节点存放的不是实际数据，而是主键id
- 当通过非聚簇索引进行查询实际数据的时候，查到主键id后还需要去聚簇索引中的B+Tree进行查询才能得到实际数据，称为回表
- 若通过非聚簇索引查询的数据为主键id时，则不用进行回表操作，这个过程称为覆盖索引

### ***B+Tree vs 二叉树***

对于有 N 个叶子节点的 B+Tree，其搜索复杂度为`O(logdN)`，其中 d 表示节点允许的最大子节点个数为 d 个。

在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据。

而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 `O(logN)`，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。

### **B+Tree vs Hash**

Hash查询对于等值查询效率高，而不适合进行范围查询

### 联合索引

- 最左匹配原则

  比如，如果创建了一个 `(a, b, c)` 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：

  - where a=1；
  - where a=1 and b=2 and c=3；
  - where a=1 and b=2；

  需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。

- **联合索引的最左匹配原则，在遇到范围查询（>、<、between、like 包括like '林%'这种）的时候，就会停止匹配，也就是范围列可以用到联合索引，但是范围列后面的列无法用到联合索引**。

索引是有序的，在 需要进行排序的时候，可以给查询字段和排序字段加上联合索引，可以避免文件排序，增加查询效率

如：

```sql
select * from order where status = 1 order by create_time asc
/*给 status 和 create_time 列建立一个联合索引，因为这样可以避免 MySQL 数据库发生文件排序。*/
```

###  索引的缺点

1. 需要占用物理空间，数量越大，占用空间越大
2. 创建索引和维护索引需要耗费时间，数据量越大时间越久
3. 会降低表的增删改效率，每次增删改查索引，B+树为了维护索引的有序性，都需要进行动态维护

### 适用索引的场景

1. 字段有唯一性限制的
2.  经常用于where查询条件的字段
3. 经常用于orderby,groupby的字段，建立索引的数据在B+树种都是已经排好序的

### 不适用索引的场景

1. Where、groupby、orderby用不到的字段
2. 字段中存在着大量重复数据的，  Mysql有一个查询优化器，查询优化器发现某个值在表的数据行中占比很高的时候，就会忽略索引，进行全表扫描
3. 表数据太少的时候
4. 经常更新的字段，因为要维护B+树的有序性，因此这种情况就会频繁的重建索引，这个过程是会影响数据库性能的

### 优化索引方法

1. 前缀索引优化
   - 使用字段中字符串的前几个字符建立索引，可以减少索引字段的大小，加快查询速度
2. 覆盖索引优化
   - 将所要查询的字段建立为联合索引，使其可以在非聚簇索引中可以直接插到所需的数据返回，省略回表操作
3. 主键索引最好是自增的
   - 因为索引是按顺序进行存储的，如果主键是自增的则在新建主键的时候只需要在最后进行追加操作即可，不需要移动数据，倘若是随机数据，则当新增的主键是在页中间的时候，则需要进行移动数据

### 索引失效的情况

1. 使用左或左右模糊匹配，如like %xx 或 like %xx%
1. 查询条件中对索引做了计算、函数、类型转换等操作
1. 没有遵循最左匹配原则
1. 在where子句中，or前的条件是索引列，or后的条件不是索引列\

### 为何一般情况下要创建一个自增主键

- 由于在InnoDB下的数据是存储在B+数中，因此当是自增主键时，则每次插入新数据的时候都是追加操作，不涉及到挪动其他记录，也不会触发叶子节点的分裂。而如果是业务字段，而不能保证有序插入，则会触发叶子节点的分裂，影响性能
- 因为在非聚簇索引下，叶子结点的值为主键，如果为业务字段作为主键长度一般会比整型做主键占用的空间更多

### MYSQL执行计划

![img](https://img-blog.csdnimg.cn/img_convert/798ab1331d1d6dff026e262e788f1a28.png)

#### 对于执行计划，参数有：

- possible_keys 字段表示可能用到的索引；
- key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；
- key_len 表示索引的长度；
- rows 表示扫描的数据行数。
- type 表示数据扫描类型，我们需要重点看这个。

type 字段就是描述了找到所需数据时使用的扫描方式是什么，常见扫描类型的**执行效率从低到高的顺序为**：

- All（全表扫描）；
- index（全索引扫描）；
- range（索引范围扫描）；
- ref（非唯一索引扫描）；
- eq_ref（唯一索引扫描）；
- const（结果只有一条的主键或唯一索引扫描）

### 索引总结

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93.drawio.png)

